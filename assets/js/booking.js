async function checkAuth() {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error || !user) {
        // Redirect to sign in page
        window.location.href = '/sign-in.html?redirect=' + encodeURIComponent(window.location.href);
        return false;
    }
    return true;
}

async function submitBooking(bookingData) {
    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            throw new Error('User must be logged in to make a booking');
        }

        // Format the data according to the database schema
        const formattedBooking = {
            service_id: bookingData.serviceId,
            provider_id: bookingData.providerId,
            consumer_id: user.id,
            status: 'pending',
            booking_date: new Date().toISOString(),
            scheduled_date: bookingData.date,
            scheduled_time: bookingData.time,
            duration_hours: parseFloat(bookingData.duration),
            location_address: bookingData.address,
            customer_phone: bookingData.phone,
            customer_email: bookingData.email,
            special_instructions: bookingData.instructions || null,
            estimated_price: bookingData.price ? parseFloat(bookingData.price) : null,
            payment_status: 'pending',
            payment_method: bookingData.paymentMethod,
            created_by_consumer: true
            // booking_reference will be auto-generated by the trigger
        };

        // First, check provider availability
        const { data: availabilityData, error: availabilityError } = await supabase
            .from('provider_availability')
            .select('*')
            .eq('provider_id', bookingData.providerId)
            .eq('day_of_week', new Date(bookingData.date).getDay())
            .eq('is_available', true);

        if (availabilityError) {
            throw new Error('Error checking provider availability');
        }

        if (!availabilityData || availabilityData.length === 0) {
            throw new Error('Provider is not available on the selected date');
        }

        // Check if the time slot is available
        const bookingTime = new Date(`2000-01-01T${bookingData.time}`);
        const endTime = new Date(bookingTime.getTime() + (parseFloat(bookingData.duration) * 60 * 60 * 1000));

        const isTimeSlotAvailable = availabilityData.some(slot => {
            const slotStart = new Date(`2000-01-01T${slot.start_time}`);
            const slotEnd = new Date(`2000-01-01T${slot.end_time}`);
            return bookingTime >= slotStart && endTime <= slotEnd;
        });

        if (!isTimeSlotAvailable) {
            throw new Error('Selected time slot is not available');
        }

        // Check for existing bookings in the same time slot
        const { data: existingBookings, error: existingBookingsError } = await supabase
            .from('bookings')
            .select('*')
            .eq('provider_id', bookingData.providerId)
            .eq('scheduled_date', bookingData.date)
            .eq('status', 'pending')
            .or(`scheduled_time.lte.${bookingData.time},scheduled_time.gte.${endTime.toTimeString().slice(0, 5)}`);

        if (existingBookingsError) {
            throw new Error('Error checking existing bookings');
        }

        if (existingBookings && existingBookings.length > 0) {
            throw new Error('This time slot is already booked');
        }

        // Create the booking
        const { data, error } = await supabase
            .from('bookings')
            .insert([formattedBooking])
            .select()
            .single();

        if (error) {
            console.error('Booking submission error:', error);
            throw new Error(error.message);
        }

        // Create booking slot
        const { error: slotError } = await supabase
            .from('booking_slots')
            .insert([{
                provider_id: bookingData.providerId,
                date: bookingData.date,
                start_time: bookingData.time,
                end_time: endTime.toTimeString().slice(0, 5),
                is_booked: true,
                booking_id: data.id
            }]);

        if (slotError) {
            console.error('Booking slot creation error:', slotError);
            // Don't throw here as the booking was created successfully
        }

        // Send notification to provider (you can implement this later)
        // await sendProviderNotification(data);

        return data;
    } catch (error) {
        console.error('Error in submitBooking:', error);
        throw error;
    }
}

// Helper function to format booking reference for display
function formatBookingReference(reference) {
    if (!reference) return '';
    return reference.toUpperCase();
}

// Helper function to get status badge class
function getStatusBadgeClass(status) {
    const statusClasses = {
        'pending': 'bg-warning',
        'confirmed': 'bg-info',
        'completed': 'bg-success',
        'cancelled': 'bg-danger'
    };
    return statusClasses[status] || 'bg-secondary';
}

// Helper function to get payment status badge class
function getPaymentStatusBadgeClass(status) {
    const statusClasses = {
        'pending': 'bg-warning',
        'paid': 'bg-success',
        'failed': 'bg-danger',
        'refunded': 'bg-info'
    };
    return statusClasses[status] || 'bg-secondary';
}

// Helper function to calculate end time based on start time and duration
function calculateEndTime(startTime, durationHours) {
    const [hours, minutes] = startTime.split(':').map(Number);
    const startDate = new Date();
    startDate.setHours(hours, minutes);
    
    const endDate = new Date(startDate.getTime() + (durationHours * 60 * 60 * 1000));
    
    return endDate.toTimeString().slice(0, 5); // Returns HH:MM format
} 